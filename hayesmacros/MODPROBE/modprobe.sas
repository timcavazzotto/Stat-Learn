
/* MODPROBE for SAS version 2.0 */;
/* This SPSS macro is used to estimate and probe two-way interactions */;
/* in OLS and logistic regression models */;
/* Written by Andrew F. Hayes */;
/* Department of Psychology */;
/* The Ohio State University */;
/* hayes.338@osu.edu */;
/* Copyright 2014 */;
/* Features for estimating and probing three-way interactions */;
/* are available in PROCESS.  See http://www.guilford.com/p/hayes3 */;

/* This code should not be posted online except through afhayes.com */;
/* without written permission. Commercial distribution is not authorized */;


%macro logiter (pt1lp=,xlp=,ylp=,iterate=10000,converge=.000000001);
  pt1lp=&pt1lp;xlp=&xlp;ylp=&ylp;
  do jjj = 1 to &iterate UNTIL (abs(LL1-LL2) < &converge);  
  	LL1=LL2;
    vt1=diag(pt1lp#pt1lp);
    b=bt1+inv(xlp`*vt1*xlp)*xlp`*(ylp-pt1lp);
    pt1lp = 1/(1+exp(-(xlp*b)));
    check = (pt1lp < .00000000000001);
    itprob = (check[+,] > 0);
    if (itprob = 0) then;do;
      check = (pt1lp > .99999999999999);
      itprob = (check[+,] > 0);
    end;
	if (itprob > 0) then;do;
	  do kkk = 1 to nrow(pt1lp);
        if (pt1lp[kkk,1]=1) then;do;
          pt1lp[kkk,1]=.99999999999999;
	    end;
	    if (pt1lp[kkk,1]=0) then;do;
          pt1lp[kkk,1]=.00000000000001;
	    end;
	  end;
	  itprob=0;
	end;
    if (itprob = 0) then;do;
      LL=ylp#log(pt1lp)+(1-ylp)#log(1-pt1lp);
	  LL2= -2*LL[+,];
    end;
    bt1=b;
  end;
  vt1=diag(pt1lp#(1-pt1lp));
  varb=inv(xlp`*vt1*xlp);
  seb=sqrt(vecdiag(varb));
%mend;

%macro modprobe (data=,y=,x=,modval=9999,jn=0,alpha=0.05,est=0, center=0,iterate=10000,converge=.000000001, change=1,
 mcfoc=0,mcmod=0,nomod=0,save=0,ptiles=0,hc3=0,decimals=10.4);       
options pagesize=32767; 
proc iml;                                                                    
use &data;        
read all var{&y &x} into dd;
read all var{&x} into x;
read all var{&y} into tempy;
nm={&y &x};
xx=(dd = .);xx=xx[,+];
j=1;do i = 1 to nrow(dd);if xx[i,1]=0 then;do;dd[j,]=dd[i,];j=j+1;end;end;
dd=dd[1:j-1,];
n = nrow(dd);
nx=1;criterr=0;errs=0;
errsm=j(10,1,0);
nyv=ncol(tempy);nxv=ncol(x);
nomod=(round(&nomod)=1);
savplot=(&save=1);ptiles=(&ptiles=1);
if (nyv ^= 1) then;do;criterr=1;errs=errs+1;errsm[errs,1]=1;end;
if (nxv < 2) then;do;criterr=1;errs=errs+1;errsm[errs,1]=2;end;
desc1=(n*t(dd)*dd)-(t(dd[+,])*dd[+,]);
desc1=desc1/(n*(n-1));
desc2=vecdiag(desc1);desc2=(desc2 = 0);desc2=desc2[+,];
if (desc2 > 0) then;do;criterr=1;errs=errs+1;errsm[errs,1]=5;end;
ddd={"D1" "D2" "D3" "D4" "D5" "D6" "D7" "D8" "D9"};
ddd1={"int_1" "int_2" "int_3" "int_4" "int_5" "int_6" "int_7" "int_8" "int_9"};
dumok=0;
hc3=(round(&hc3)=1);
mcfoc=round(&mcfoc);mcmod=round(&mcmod);
if (mcfoc < 0) then;do;mcfoc=0;end;
if (mcfoc > 4) then;do;mcfoc=0;end;
if (mcmod < 0) then;do;mcmod=0;end;
if (mcmod > 4) then;do;mcmod=0;end;
if ((mcmod > 0) & (mcfoc > 0)) then;do;errs=errs+1;errsm[errs,1]=3;criterr=1;end;
mcloc=(mcfoc > 0);
con=j(n,1,1);
ncovs=ncol(x)-2;
if ((mcfoc > 0) | (mcmod >0)) then;do;
  temp=dd;temp[rank(dd[,(ncol(dd)-mcloc)]),]=dd;dd=temp;
  dummy=design(dd[,(ncol(dd)-mcloc)]);
  nvls=ncol(dummy);nnvls=dummy[+,];
  toosmall=(nnvls < 2);toosmall=toosmall[,+];
  mnvls=min(nnvls`);
  if (toosmall > 0) then;do;criterr=1;errs=errs+1;errsm[errs,1]=6;end;
  if (nvls > 10) then;do;criterr=1;errs=errs+1;errsm[errs,1]=4;end;
  if (criterr=0) then;do;
    dumok=1;
    nnvls=j(nvls,1,0);
    nnvls[1,1]=dd[1,ncol(dd)-mcloc];
    temp=2;
    do i = 2 to n;
      if (dd[i,ncol(dd)-mcloc] ^= nnvls[(temp-1),1]) then;do;
        nnvls[temp,1]=dd[i,ncol(dd)-mcloc];temp=temp+1;
      end;
    end;
    dummy=dummy[,2:ncol(dummy)];
    if ((mcfoc=4) | (mcmod=4)) then;do;
      minus1=j(1,ncol(dummy),-1);
	  do k=1 to n;
	    if (dummy[k,+] = 0) then;do;dummy[k,]=minus1;end;
	  end;
    end;
    if (((mcfoc=2) | (mcfoc=3)) | ((mcmod=2) | (mcmod=3))) then;do;
      do k=1 to n;
	    if (dummy[k,+] > 0) then;do;
	      do i = 1 to ncol(dummy) while (dummy[k,i] = 0);
  		    dummy[k,i]=1;
		  end;
	    end;
	  end;
      if ((mcfoc=3)|(mcmod=3)) then;do;
        conmat1={-8 1 1 1 1 1 1 1 1,
                 0 -7 1 1 1 1 1 1 1,
                 0 0 -6 1 1 1 1 1 1,
                 0 0 0 -5 1 1 1 1 1,
                 0 0 0 0 -4 1 1 1 1,
                 0 0 0 0 0 -3 1 1 1,
                 0 0 0 0 0 0 -2 1 1,
                 0 0 0 0 0 0 0 -1 1};
        do i = 1 to 8;conmat1[i,]=conmat1[i,]/(10-i);end;
   	    conmat1=conmat1[(10-nvls):8,(10-nvls):9]`;
        do k = 1 to n;
	      dummy[k,]=conmat1[(dummy[k,+]+1),];
	    end;
      end;
    end;
    nx=ncol(dummy);
    xname=ddd[1,1:nx];
    xdata=dummy;
    xname2=nm[1,(ncol(nm)-mcloc)];
	xname2=xname2||xname;
    indlbs=xname`;
    dummat=j((nx+1),nx,0);
    dummat[(2:nrow(dummat)),]=I(nx);
    if ((mcfoc=2)|(mcmod=2)) then;do;
      do i = 1 to nrow(dummat); 
	    do j = 1 to (i-1);
	      dummat[i,j]=1;
	    end;
	  end;
    end;
    if ((mcfoc=3) | (mcmod=3)) then;do;dummat=conmat1;end;
    if ((mcfoc=4) | (mcmod=4)) then;do;dummat[1,]=minus1;end;
  end;
  dummat=nnvls||dummat;
end;
print "******************* MODPROBE Procedure for SAS Release 2.0 *******************";
print "           Written by Andrew F. Hayes, Ph.D.  www.afhayes.com           ";
print "*****************************************************************************";
if (criterr=0) then;do;
  y=dd[,1];
  ovals=ncol(design(dd[,1]));
  jnerr = 0;
  itprob = 0;
  if (ovals = 2) then;do;
    omx = max(y[,1]);
    omn = min(y[,1]);
    y[,1]=(y[,1]=omx);
    rcd = (omn||0)//(omx||1);
  end;
  jn = floor(&jn);
  if (ovals = 2) then;do;
    if (jn > 1) then;do; 
	  jn = 1;
  	  jnerr = 1;
	end;
  end;
  xd = 1.959963984549954;
  cilm = 0.05;
  alperr = 1;
  sstotal = ssq(y-((y[+,])/n));
  nms={&x};
  outv={&y};
  mdtr = nms[1,ncol(nms)];
  fciv = nms[1,ncol(nms)-1];
  centerv={" "};
  if ((&center = 1) & (mcmod=0)) then;do;
    dd[,ncol(dd)]=dd[,ncol(dd)]-(dd[+,ncol(dd)]/n);
	centerv=centerv||mdtr;
  end;
  if ((&center = 1) & (mcfoc=0)) then;do;
    dd[,(ncol(dd)-1)]=dd[,(ncol(dd)-1)]-(dd[+,(ncol(dd)-1)]/n);
	centerv=centerv||fciv;
  end;
  if ((mcfoc=0) & (mcmod=0)) then;do;
    inter = dd[,(ncol(dd)-1)]#dd[,ncol(dd)];
    con = j(n,1,1);
    x=con||dd[,2:ncol(dd)];
	if (nomod = 0) then;do;x=x||inter;end;
    nms=nm[1,2:ncol(dd)];
  end;
  if ((mcfoc ^=0) | (mcmod ^=0)) then;do;
    inter=j(n,nx,0);
	do i = 1 to nx;
	  inter[,i] = dummy[,i]#dd[,(ncol(dd)-(1-mcloc))];
    end;
    if (ncovs = 0) then;do;
      x=con||dd[,(ncol(dd)-(1-mcloc))]||dummy;
      if (nomod=0) then;do;x=x||inter;end;
	  nms=nm[1,(ncol(dd)-(1-mcloc))]||(ddd[1,1:ncol(dummy)])||(ddd1[1,1:ncol(dummy)]);
	end;
	if (ncovs > 0) then;do;
	  x=con||dd[,2:(1+ncovs)]||dd[,(ncol(dd)-(1-mcloc))]||dummy;
      if (nomod=0) then;do;x=x||inter;end;
	  nms=nm[1,2:(1+ncovs)]||nm[1,(ncol(dd)-(1-mcloc))]||(ddd[1,1:ncol(dummy)])||(ddd1[1,1:ncol(dummy)]);
	end;
  end;
  xmns=x[+,]/n;
  focvals = 1||0||0;
  highwarn = 0;lowwarn = 0;
  if (ncol(x) > (2*nx+2)) then;do;
    covmns = 1||xmns[1,2:(ncol(x)-1-(2*nx))];
    focvals = covmns||0||0;
  end;
  dfres = n-ncol(x);
  tval=5.990731+18.568800*(1/dfres);
  if (&jn = 2) then;do;
    if (dfres < 50) then;do;
	  print "Simultaneous inference is not available at this sample size";
      jn = 0;
    end;
  end;
  if (ovals = 2) then;do;
    pt2=j(n,1,(y[+,]/n));
    LL3=y#log(pt2)+(1-y)#log(1-pt2);
    LL3=-2*LL3[+,];
    pt1=j(n,1,0.5);
    bt1=j(ncol(x),1,0);
    LL1 = 0;
    LL2 = LL3;
	%logiter (pt1lp=pt1,xlp=x,ylp=y,iterate=&iterate,converge=&converge);
    if (jjj > &iterate) then;do;
      itprob = 2;
    end;
    if (&alpha = 0.10) then;do;
      tval=2.70554345409541221538;
      cilm = .10;alperr=0;
    end;
    else if (&alpha = .01) then;do;
      tval=6.634896601021211218135;
      cilm=.01;alperr=0;
    end;
    else if (&alpha = .05) then;do;
      tval=3.8414588206941250351219;
      cilm=0.05;alperr=0;
    end;
    else;do;
      alperr = 1;
    end;
  end;
  else if (ovals ^= 2) then;do;
    invxtx=inv(x`*x);
    b=invxtx*x`*y;
    resid=y-(x*b);
    ssresid=ssq(resid);
    msresid=ssresid/dfres;
    varb=msresid*inv(x`*x);
	* start here;
	seint=sqrt(varb[nrow(varb),nrow(varb)]);
    k3=nrow(b);
    if (hc3 = 1) then;do;
	  xhc=x;h=xhc[,1];
      do i3=1 to n;
	    h[i3,1]=xhc[i3,]*invxtx*(xhc[i3,])`;
	  end;
	  do i3=1 to k3;
	    xhc[,i3]=(resid[,ncol(resid)]/(1-h))#xhc[,i3];
	  end;
	  varb=(invxtx*xhc`*xhc*invxtx);
	end;
	*end here;

    seb = sqrt(vecdiag(varb));
    r2=1-(ssresid/sstotal);
	if ((mcfoc ^= 0) | (mcmod ^=0)) then;do;
      ytp=y;
	  xtp=x[,1:(ncol(x)-nx)];
	  btp=inv(xtp`*xtp)*xtp`*ytp;
	  residt=ytp-(xtp*btp);
	  ssresidt=ssq(residt);
	  r2noint=1-(ssresidt/sstotal);
	end;
    pr=ncol(x)-1;
    *start here;
    lmat=I(nrow(b));lmat=lmat[,2:ncol(lmat)];
	f=(((lmat`)*b)`*inv(lmat`*varb*lmat)*(lmat`*b))/pr;
	*end here;
    pf=1-probf(f,pr,dfres);
    pf=r2||f||pr||dfres||pf||n;
    if (&alpha = .10) then;do;
      xd = 1.644853626951472;
      tval=4.604839+10.883656*(1/dfres);
      cilm = .10;
      alperr = 0;
    end;
    else if (&alpha = .01) then;do;
      xd = 2.5758293035489;
      tval=9.207688+44.698748*(1/dfres);
      cilm=.01;
      alperr = 0;
    end;
    else if (&alpha = .05) then;do;
      xd = 1.959963984540054;
      tval=5.990731+18.568800*(1/dfres);
      cilm = .05;
      alperr = 0;
    end;
  end;
  if (itprob = 0) then;do;
    tstat = b/seb; 
    if (ovals ^= 2) then;do;
      p=2*(1-probt(abs(tstat),dfres));
    end;
    else if (ovals = 2) then;do;
      p=2*(1-probnorm(abs(tstat)));
    end;
    outp=b||seb||tstat||p;
    nms="CONSTANT"//nms`//"INTERACT";
    if (jn < 2) then;do;
      if (ovals ^=2) then;do;
        tval=(dfres*(exp((dfres-(5/6))*((xd/(dfres-(2/3)+(.11/dfres)))*(xd/(dfres-(2/3)+(.11/dfres)))))-1));
		outp=outp||(b-sqrt(tval)#seb)||(b+sqrt(tval)#seb);
      end;
    end;
    bb=tval;
    rns = {"Outcome Variable:" "Focal Predictor Variable:" "Moderator Variable:"};
    vs = outv//fciv//mdtr;
    print vs [rowname = rns label = "Variables"];
	if (dumok = 1) then;do;
      if (mcfoc > 0) then;do;
	    print "Coding of categorical focal predictor for analysis:";
        print dummat [colname=xname2 label = " " format=5.2];
      end;
	  else if (mcmod > 0) then;do;
	    print "Coding of categorical moderator variable for analysis:";
        print dummat [colname=xname2 label = " " format=5.2];
      end;
	end;
    print "*****************************************************************************";
    if (ovals = 2) then;do;
      nmsd = outv||"Analysis";
	  print "Coding of binary Y for analysis:";
      print rcd [colname = nmsd label = " " format = 5.2];
	  outp=outp||(outp[,1]-sqrt(tval)#outp[,2])||(outp[,1]+sqrt(tval)#outp[,2]);
      LLdiff = LL3-LL2;
	  LL4=LL2;
	  pvalue=1-probchi(LLdiff,nrow(b));
      mcF = LLdiff/LL3;
      cox = 1-exp(-LLdiff/n);
      nagel=cox/(1-exp(-(LL3)/n));
      pf = LL2||LLdiff||pvalue||mcF||cox||nagel||n;
      cns = {"-2LL" "Model LL" "p-value" "McFadden" "CoxSnell" "Nagelkrk" "n"};
	  rntmp=" ";
      print pf [colname = cns rowname = " " label = "Logistic Regression Summary" format = &decimals];
      cns = {"Coeff" "se" "Z" "p" "LLCI" "ULCI"};
      print outp [rowname = nms colname = cns label = "Model" format = &decimals];
	  varbtmp=varb;btmp=b;LL2f=LL2;pt1lp=j(n,1,0.5);
	  ylp=y;xlp=x[,1:(ncol(x)-nx)];
	  bt1=j(ncol(xlp),1,0);
	  %logiter (pt1lp=pt1lp,xlp=xlp,ylp=ylp,iterate=&iterate,converge=&converge);
	  LLdiff=LL2-LL2f;
	  b=btmp;varb=varbtmp;
	  pchi=1-probchi(LLdiff,nx);
	  rcha=LLdiff||nx||pchi;
    end;
    if (ovals ^= 2) then;do;
	  cns = {"R-sq" "F" "df1" "df2" "p" "n"};
	  blk=" ";
      print pf [colname = cns rowname = blk label = "Complete Model Regression Summary" format = &decimals];
      * start here;
      lmat=j(nrow(b),1,0);lmat[nrow(lmat),1]=1;
      fcha=((((lmat`)*b)`*inv(lmat`*varb*lmat)*(lmat`*b)))/1;
	  rcha=((b[nrow(b),1]/seint)*(b[nrow(b),1]/seint))*(1-r2)/dfres;
	  * end here;
      rcha = rcha||fcha||1||dfres||outp[(pr+1),4];
      cns = {"Coeff" "se" "t" "p" "LLCI" "ULCI"};
      print outp [rowname = nms colname = cns label = "Regression Model" format = &decimals];
      if ((mcfoc > 0) | (mcmod > 0)) then;do;
	    rcha=r2-r2noint;
		*start here;
        lmat=j((nrow(b)-nx),nx,0);
		lmat2=I(nx);lmat=lmat//lmat2;
		fcha=((((lmat`)*b)`*inv(lmat`*varb*lmat)*(lmat`*b)))/nx;
        *end here;
		pvalr2c=1-probf(fcha,nx,dfres);
		rcha=rcha||fcha||nx||dfres||pvalr2c;
	  end;
	end;
	if ((mcfoc = 0) & (mcmod = 0) & (nomod = 0)) then;do;
	  cprod=nms[(ncol(dd)-1),1]||"X"||nms[ncol(dd),1];
      print cprod [label = "Interact is defined as:"];
	end;
	if (((mcfoc > 0) | (mcmod > 0)) & (nomod = 0)) then;do;
	  intkey="a"||"b"||"c"||"d"||"e";
      do i = 1 to nx;
	    tmpintk=ddd1[1,i]||" : "||ddd[1,i]||" X "||nm[1,(ncol(dd)-(1-mcloc))];
	    intkey=intkey//tmpintk;
      end;
	  intkey=intkey[2:nrow(intkey),];
	  print intkey [label = "Product terms key:"];
	end;
    if ((&change ^= 0) & (nomod = 0)) then;do;
	  if (ovals ^= 2) then;do;
		cns = {"R2-chng" "F" "df1" "df2" "p"};
		print rcha [label = "R-square increase due to interaction:" colname=cns format=&decimals];
      end;
      if (ovals = 2) then;do;
        cns = {"Chi-sq" "df" "p"};
		print rcha [label = "Likelihood ratio test for interaction" colname=cns format=&decimals];
      end;
	end;
    print "*****************************************************************************";
	if (nomod=0) then;do;
	  mdvar=x[,(ncol(x)-1)];
	  if ((mcfoc = 0) & (mcmod = 0)) then;do;
        g1=b[(ncol(x)-2),1];
        g3=b[ncol(x),1];
        vg1=varb[(ncol(x)-2),(ncol(x)-2)];
        vg3=varb[ncol(x),ncol(x)];
        covg1g3=varb[(ncol(x)-2),ncol(x)];
	  end;
	  if ((mcfoc > 0) | (mcmod > 0)) then;do;
        mdvar=x[,(ncol(x)-(2*nx))];
	  end;
      mdmin=min(mdvar);
      mdmax=max(mdvar);
      fvar=x[,(ncol(x)-2)];
      nval=ncol(design(mdvar));
      fvmin=min(fvar);
      fvmax=max(fvar);
      if (&modval = 9999) then;do;
        if (jn < 1) then;do;
          mnmd=mdvar[+]/n;
          tmp=j(n,1,mnmd);
          sdmd = sqrt(ssq(mdvar-tmp)/(n-1));
          probeval = (mnmd-sdmd)//mnmd//(mnmd+sdmd);
		  if (ptiles=1) then;do;
            tmp=mdvar;tmp[rank(mdvar[,1]),]=mdvar;mdvar=tmp;
			probeval=mdvar[floor(0.25*n),1]//mdvar[floor(0.5*n),1]//mdvar[floor(0.75*n),1];
		  end;
        end;
      end;
      if (nval = 2) then;do;
        probeval = j(2,1,0);
        probeval[1,1]=min(mdvar);
        jn = 0;
        do i = 1 to n;
          if (mdvar[i,1] ^= probeval[1,1]) then;do;
   	        probeval[2,1]=mdvar[i,1];
	        goto stpit;
	      end;
        end;
        stpit:
      end;
      if (&modval ^= 9999) then;do;
        if (jn < 1) then;do;
  	      probeval = &modval;
  	    end;
      end;
      if (jn < 1) then;do;
	    outp = j(nrow(probeval),7,0);
	    if ((mcfoc=0) & (mcmod = 0)) then;do;
          do i = 1 to nrow(probeval);
            x2=probeval[i,1];
	        w1=g1+g3*x2;
	        varw1=vg1+(2*x2*covg1g3)+((x2*x2)*vg3);
	        sew1=sqrt(varw1);
	        t1=w1/sew1;
	        LLCI=(w1-sqrt(tval)#sew1);
	        ULCI=(w1+sqrt(tval)#sew1);
	        if (ovals ^= 2) then;do;
              p=2*(1-probt(abs(t1),dfres));
            end;
	        if (ovals = 2) then;do;
	          p=2*(1-probnorm(abs(t1)));
	        end;
            do j = 0 to 20;
	          temp=(fvmin+j*((fvmax-fvmin)/20));
	          if (ncol(x)>4) then;do;
		        focvals = focvals//(covmns||temp||probeval[i,1]);
		      end;
	          else;do;
		        focvals = focvals//(1||temp||probeval[i,1]);
		      end;
			end;
			outp[i,]=x2||w1||sew1||t1||p||LLCI||ULCI;
          end;
          focvals = focvals[2:nrow(focvals),];
          inter2=focvals[,(ncol(focvals)-1)]#focvals[,ncol(focvals)];
          focvals=focvals||inter2;
          yhat=focvals*b;
          focvals=focvals[,(ncol(focvals)-2):(ncol(focvals)-1)]||yhat;
        end;
		if ((mcfoc > 0) | (mcmod > 0)) then;do;
          focvals=j(1,(ncol(x)+1),1);
		  if (mcfoc > 0) then;do;
		    print "Conditional Effect of Focal Predictor at Values of the Moderator Variable";
			rnn2=mdtr;
			matt=j(nx,6,0);
		  end;
          do jj = 1 to nrow(probeval);
            if (mcfoc > 0) then;do;
              do ii = 1 to nx;
                g1=b[(ncol(x)-(2*nx)+ii),1];
				g3=b[(ncol(x)-nx+ii),1];
				vg1=varb[(ncol(x)-(2*nx)+ii),(ncol(x)-(2*nx)+ii)];
				vg3=varb[(ncol(x)-nx+ii),(ncol(x)-nx+ii)];
				covg1g3=varb[(ncol(x)-(2*nx)+ii),(ncol(x)-nx+ii)];
				x2=probeval[jj,1];
				w1=g1+g3*x2;
				varw1=vg1+(2*x2*covg1g3)+((x2*x2)*vg3);
				sew1=sqrt(varw1);
				t1=w1/sew1;
				if (ovals ^= 2) then;do;
				  LLCI=(w1-sqrt(tval)#sew1);
				  ULCI=(w1+sqrt(tval)#sew1);
				  p=2*(1-probt(abs(t1),dfres));
				  cnms="Coeff"||"se"||"t"||"p"||"LLCI"||"ULCI";
				  matt[ii,]=w1||sew1||t1||p||llci||ulci;
				end;
				if (ovals = 2) then;do;
				  LLCI=(w1-sqrt(tval)#sew1);
				  ULCI=(w1+sqrt(tval)#sew1);
				  p=2*(1-probnorm(abs(t1)));
				  cnms="Coeff"||"se"||"Z"||"p"||"LLCI"||"ULCI";		
				  matt[ii,]=w1||sew1||t1||p||llci||ulci;
                end; 
			  end;
              rnms=xname`;
			  mdvalpr=probeval[jj,1];
			  print mdvalpr [label="Moderator value:" rowname=rnn2 format=&decimals];
			  print matt [label=" " rowname=rnms colname=cnms format=&decimals];
			  xprob=x[,(ncol(x)-(2*nx))]-mdvalpr;
			  do kk = 1 to nx;
			    xprob=xprob||(xprob[,1]#x[,(ncol(x)-(2*nx)+kk)]);
			  end;
			  xprob=x[,(1:(ncol(x)-(2*nx)-1))]||xprob;
			  if (ovals ^= 2) then;do;
                bmultc=inv(xprob`*xprob)*xprob`*y;
				residc=y-(xprob*bmultc);
				ssresidc=ssq(residc);
				r2c=r2-(1-(ssresidc/sstotal));
				fcha2=(dfres*r2c)/(nx*(1-r2));
				*start here;
                if (hc3 = 1) then;do;
				  do kk=1 to nx;
				    xprob=xprob||x[,(ncol(x)-(2*nx)+kk)];
				  end;
                  bmultc=inv(xprob`*xprob)*xprob`*y;
				  k3=nrow(bmultc);
                  xhc=xprob;h=xhc[,1];
                  do i3=1 to n;
	                h[i3,1]=xhc[i3,]*inv(xprob`*xprob)*(xhc[i3,])`;
	              end;
	              do i3=1 to k3;
	                xhc[,i3]=(resid[,ncol(resid)]/(1-h))#xhc[,i3];
	              end;
	              varbc=(inv(xprob`*xprob)*xhc`*xhc*inv(xprob`*xprob));
				  lmat=j((nrow(bmultc)-nx),nx,0);
                  lmat2=I(nx);
				  lmat=lmat//lmat2;
				  fcha2=((((lmat`)*bmultc)`*inv(lmat`*varbc*lmat)*(lmat`*bmultc)))/nx;
	            end;
				*end here;


				pvalr2cc=1-probf(fcha2,nx,dfres);
				rcha2=r2c||fcha2||nx||dfres||pvalr2cc;
				cnms="R2-chng"||"F"||"df1"||"df2"||"p";
				print rcha2 [label = "Test of equality of conditional means at this value of the moderator"
				   colname = cnms format = &decimals];
			  end;
			  if (ovals = 2) then;do;
                btmp=b;
				pt1lp=j(j,1,0.5);
				ylp=y;
				xlp=xprob;
				bt1=j(ncol(xlp),1,0);
				%logiter (pt1lp=pt1,xlp=xlp,ylp=ylp,iterate=&iterate,converge=&converge);
				LLdiff=LL2-LL4;
				b=btmp;
				varb=varbtmp;
				pchi=1-probchi(lldiff,nx);
				rcha2=LLdiff||nx||pchi;
				cnms="Chi-sq"||"df"||"p";
				print "Test of equality of log odds conditioned on this value of the moderator";
				print rcha2 [label = " " colname = cnms format = &decimals];
			  end;
            end;
            ttttt=j(nrow(dummat),1,probeval[jj,1]);
			ttttt=ttttt||dummat[,2:ncol(dummat)];
			do kkk=1 to nx;
              ttttt=ttttt||(ttttt[,1]#ttttt[,(1+kkk)]);
			end;
			ones=j(nrow(dummat),1,1);
            if (ncol(x) > (2*nx+2)) then;do;
              covmnmat=j(nrow(ttttt),ncol(covmns),0);
			  do kkk=1 to nrow(ttttt);
                covmnmat[kkk,]=covmns;
			  end;
			  ttttt=covmnmat||ttttt;
			end;
			if (ncol(x) <= (2*nx+2)) then;do;
              ttttt=ones||ttttt;
			end;
			focmtt=dummat[,1]||ttttt;
            focvals=focvals//focmtt;
			if (mcfoc > 0) then;do;
              yhat=dummat[,1]||(ttttt*b);
		      cmnms=fciv||"yhat";
			  if (ovals ^= 2) then;do;
			    print "Estimated conditional means at this value of the moderator";
			  end;
			  if (ovals = 2) then;do;
			    print "Estimated conditional log odds at this value of the moderator";
			  end;
			  print yhat [label = " "
			    colname = cmnms format=&decimals];
			  if (jj ^= nrow(probeval)) then;do;
		        print "---------------------------------";
			  end;
		    end;
		  end;
          focvals=focvals[2:nrow(focvals),];
		  yhat=focvals[,2:ncol(focvals)]*b;
		  focvals=focvals[,1]||focvals[,(ncol(focvals)-(2*nx))]||yhat;
		  cnms=fciv||mdtr||"yhat";
		  if (mcmod > 0) then;do;
            cnms=mdtr||fciv||"yhat";
		  end;
		end;

        if (mcmod > 0) then;do;
          outp=j((nx+1),7,0);
		  bcatm=b[(ncol(x)-(2*nx)),1]//b[(ncol(x)-nx+1):ncol(x),1];
		  outp[,1]=dummat[,1];
		  bcatcov=varb[(ncol(x)-nx):ncol(x),(ncol(x)-nx):ncol(x)];
		  bcatcov[1,1]=varb[(ncol(x)-(2*nx)),(ncol(x)-(2*nx))];
		  bcatcov[2:nrow(bcatcov),1]=varb[(ncol(x)-nx+1):ncol(x),(ncol(x)-2*nx)];
		  bcatcov[1,2:nrow(bcatcov)]= (varb[(ncol(x)-nx+1):ncol(x),(ncol(x)-2*nx)])`;
		  do i = 1 to nrow(dummat);
		    catmval=1||dummat[i,2:ncol(dummat)];
			condeff=catmval*bcatm;
			condse=sqrt(catmval*bcatcov*catmval`);
			outp[i,2:3]=condeff||condse;
		  end;
		  outp[,4]=outp[,2]/outp[,3];
		  outp[,5]=2*(1-probt(abs(outp[,4]),dfres));
		  outp[,6]=outp[,2]-sqrt(tval)#outp[,3];
		  outp[,7]=outp[,2]+sqrt(tval)#outp[,3];
          if (ovals ^= 2) then;do;
		    cnmms=xname2[1,1]||"Coeff"||"se"||"t"||"p"||"LLCI"||"ULCI";
		  end;
		  if (ovals = 2) then;do;
            outp[,5]=2*(1-probnorm(abs(outp[,4])));
			cnmms=xname2[1,1]||"Coeff"||"se"||"Z"||"p"||"LLCI"||"ULCI";
		  end;
		  rnmms=" ";
		  print outp [label="Conditional Effect of Focal Predictor in Groups Defined by the Moderator Variable" 
		    colname=cnmms rowname = rnmms format=&decimals];
		end;

        if ((mcfoc=0) & (mcmod=0)) then;do;
          if (ovals ^= 2) then;do;
            cnms=nms[(ncol(x)-1),1]||"Coeff"||"se"||"t"||"p"||"LLCI"||"ULCI";
          end;
          if (ovals = 2) then;do;
            cnms=nms[(ncol(x)-1),1]||"Coeff"||"se"||"Z"||"p"||"LLCI"||"ULCI";
          end;
		  print outp [colname = cnms rowname = "" label = "Conditional Effect of Focal Predictor at Values of the Moderator Variable" format = &decimals];
		end;
        if (probeval[1,1] < mdmin) then;do;
	      lowwarn = 1;
	    end;

        if (probeval[nrow(probeval),1] > mdmax) then;do;
	      highwarn = 1;
	    end; 

        if (nval > 2) then;do;
	      if (&modval = 9999) then;do;
	        if (mcmod=0) then;do;
			  if (ptiles ^= 1) then;do;
	            print "Moderator values are the sample mean and plus/minus one SD from mean";
		      end;
			  if (ptiles = 1) then;do;
				print "Moderator values are the 25th, 50th, and 75th percentiles of the moderator distribution";
			  end;
	          if ((highwarn = 1) & (ptiles=0)) then;do;
  		        print "Warning: One SD above the mean is beyond the available data";
		      end;
	          if ((lowwarn = 1) & (ptiles=0)) then;do;
		        print "Warning: One SD below the mean is beyond the available data";
		      end;
	        end;
          end;
        end;
        if (nval = 2) then;do;
	      if (&modval = 9999) then;do;
	        print "The moderator variable is dichotomous";
	      end;
	    end;
      end; 
      if (jn > 0) & (nval > 2) & (mcmod=0) & (mcfoc = 0) then;do;
	    ajn = (bb*vg3)-(g3*g3);
	    bjn = 2*((bb*covg1g3)-(g1*g3));
	    cjn = (bb*vg1)-(g1*g1);
	    radarg=(bjn*bjn)-(4*ajn*cjn);
	    den = 2*ajn;
	    nrts = 0;
        if ((radarg >= 0) & (den ^= 0) & (nval ^= 2)) then;do;
	  	  x21 = (-bjn+sqrt(radarg))/den;
		  x22 = (-bjn-sqrt(radarg))/den;
		  roots = 0;
		  if (x21 >= mdmin) then;do;
	        if (x21 <= mdmax) then;do;
		      nrts = 1;
		      roots = roots//x21;
		  	end;
		  end;
		  if (x22 >= mdmin) then;do;
			if (x22 <= mdmax) then;do;
			  nrts = nrts+1;
			  roots = roots//x22;
			end;
	      end;
		  if (nrts > 0) then;do;
			roots = roots[2:nrow(roots),1];
			cuts=j(nrow(roots),2,0);
			do j=1to nrow(roots);
			  tmp=(dd[,ncol(dd)] < roots[j,1]);
              cuts[j,1]=tmp[+,]/(.01*n);
              tmp=(dd[,ncol(dd)] > roots[j,1]);
              cuts[j,2]=tmp[+,]/(.01*n);
			end;
			roots=roots||cuts;
			if (jn = 1) then;do;
			  clbs="Value"||"% below"||"% above";
			  print "Moderator Value(s) Defining Nonsimultaneous Johnson-Neyman Significance Region(s)";
			  print roots [label = "" colname = clbs format = &decimals];
            end;
            if (jn = 2) then;do;
			  clbs="Value"||"% below"||"% above";
			  print "Moderator Value(s) Defining Simultaneous Johnson-Neyman Significance Region(s)";
			  print roots [label = "" colname = clbs format = &decimals];
            end;
	      end;
          if (nrts = 0) then;do;
            print "There are no regions of significance for the procal predictor within the observed range of the moderator";
          end;
        end;
        probeval = 0;
	    do j = 0 to 20;
	      temp=(mdmin+j*((mdmax-mdmin)/20));
	      probeval = probeval//temp;
	    end;
	    probeval=probeval//(mdmax+5);
	    if (nrts > 0) then;do;
	      do i = 1 to nrts;
	        do j = 1 to (nrow(probeval)-1);
		      if (roots[i,1]) > probeval[j,1] then;do;
		        if roots[i,1] < probeval[(j+1),1] then;do;
			      probeva2 = probeval[1:j,1]//roots[i,1]//probeval[(j+1):nrow(probeval),1];
			    end;
		      end;
		    end;
		    probeval=probeva2;
	      end;
	    end;
        probeval=probeval[2:(nrow(probeval)-1),1];
        outp = j(nrow(probeval),7,0);
        do i = 1 to nrow(probeval);
	      x2=probeval[i,1];
	      w1=g1+g3*x2;
	      varw1 = vg1+(2*x2*covg1g3)+((x2*x2)*vg3);
	      sew1 = sqrt(varw1);
	      t1=w1/sew1;
	      LLCI = (w1-sqrt(tval)#sew1);
	      ULCI = (w1+sqrt(tval)#sew1);
          if (ovals ^= 2) then;do;
		    p=2*(1-probt(abs(t1),dfres));
            cnms=nms[(ncol(x)-1),1]||"Coeff"||"se"||"t"||"p"||"LLCI"||"ULCI";
            outp[i,]=x2||w1||sew1||t1||p||LLCI||ULCI;
		  end;
          if (ovals = 2) then;do;
		    p=2*(1-probnorm(abs(t1)));
            cnms=nms[(ncol(x)-1),1]||"Coeff"||"se"||"Z"||"p"||"LLCI"||"ULCI";
            outp[i,]=x2||w1||sew1||t1||p||LLCI||ULCI;
          end;
	    end;
	    if (jn = 2) then;do;
	      outp = outp[,1]||outp[,6:7];
	      cnms = nms[(ncol(x)-1),1]||"LLCI"||"ULCI";
	    end;
        print "Conditional Effect of Focal Predictor at Values of Moderator Variable";
	    print outp [colname = cnms label = "" format = &decimals];
	    print "Alpha level used for Johnson-Neyman method and confidence intervals:";
	    print cilm [label = "" format = &decimals];
      end;
      if ((&modval ^= 9999) & (mcmod=0)) then;do;
        if (&modval < mdmin) then;do;
	      print "Warning: MODVAL is outside of the range of the data";
	    end;
        if (&modval > mdmax) then;do;
	      print "Warning: MODVAL is outside of the range of the data";
	    end;
      end;
      if ((mcfoc=0) & (mcmod = 0)) then;do;
        if (jn < 1) then;do;
	      fvdes = ncol(design(fvar));
	      if (fvdes = 2) then;do;
	        fv1 = min(fvar);
	        fv2 = max(fvar);
	        r = 1;
	        do j = 1 to nrow(focvals);
	          if (focvals[j,1]=fv1) then;do;
		        focvals[r,]=focvals[j,];
		        r=r+1;
		      end;
		      if (focvals[j,1]=fv2) then;do;
		        focvals[r,]=focvals[j,];
		        r=r+1;
		      end;
            end;
	        focvals = focvals[1:(r-1),];
	      end;
	    end;
	  end;
      if ((&est = 1) & (jn < 1)) then;do;
	    if ((mcfoc=0) & (mcmod=0)) then;do;
          cnms = (nms[(ncol(x)-2):(ncol(x)-1),1])`|| "YHAT";
		end;
        if (ovals = 2) then;do;
	      prob = exp(focvals[,3])/(1+exp(focvals[,3]));
		  focvals = focvals||prob;
		  cnms = cnms||"PROB";
		end;   
        print "*****************************************************************************";
        print "Data for Visualizing Conditional Effect of Focal Predictor";
	    print focvals [colname = cnms label = "" format = &decimals];
        if (savplot=1) then;do;
          create estvals from focvals [colname=cnms];
          append from focvals;
		end;
		if (ncovs > 0) then;do;
          print "NOTE: For data above, covariate are set to their sample means";
		end;
	  end;
    end;
    /* end */;
	print "************************ ANALYSIS NOTES AND WARNINGS ************************";
	print cilm [label = "Alpha level used for confidence intervals:"];
    if (alperr = 1) then;do;
      if (jn > 0) then;do;
	    print "ERROR: Inappropriate alpha level requested.  Alpha set to 0.05";
      end;
    end;
    if (jnerr = 1) then;do;
	  print "NOTE: Simultaneous inference not available for logistic regression.  Nonsimultaneous results are printed";
    end;
	if (hc3 = 1) then;do;
      print "NOTE: The HC3 standard error estimator was used.";
    end;
  end;
  if (itprob = 1) then;do;
    print "ERROR: There was a problem during iteration.  All output is suppressed.";
  end;
  if (itprob = 2) then;do;
    print "ERROR: The convergence criterion was not attained.  All output is suppressed.";
  end;
  if (ncol(centerv) > 1) then;do;
    centerv=centerv[,2:ncol(centerv)];
	print "NOTE: The following variables were mean centered prior to analysis:";
	print centerv [label = " "];
  end;
end;  /* end of criterr condition */;

do i = 1 to errs;
  if (errsm[i,1]=1) then;do;
    print "ERROR: Only one variable can be specified as the outcome Y.";
  end;
  if (errsm[i,1]=2) then;do;
    print "ERROR: You must specify at least two variables in the X= list.";
  end;
  if (errsm[i,1]=3) then;do;
    print "ERROR: Focal predictor and moderator cannot both be specified as multicategorical.";
  end;
  if (errsm[i,1]=4) then;do;
    print "ERROR: Categorical variables cannot have more than 10 categories.";
  end;
  if (errsm[i,1]=5) then;do;
    print "ERROR: One of the variables in the model exhibits no variation.";
  end;
  if (errsm[i,1]=6) then;do;
    print "ERROR: Each group must have at least two cases.";
  end;
end;
if ((&modval ^= 9999) & (mcmod ^= 0)) then;do;
  print "NOTE: MODVAL option not available for use with a multicategorical moderator.";
end;
quit;
options pagesize=54;
%mend;




